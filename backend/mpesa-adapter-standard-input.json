{
    "language": "Solidity",
    "sources": {
      "MpesaTreasuryAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20Minimal {\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\ninterface IPackageManagerMinimal {\n    function SERVER_ROLE() external view returns (bytes32);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getPackage(uint256 id) external view returns (\n        uint256 entryUSDT,\n        uint256 exchangeRate,\n        uint64 cliff,\n        uint64 duration,\n        uint16 vestBps,\n        uint16 referralBps,\n        bool active,\n        bool exists,\n        string memory name\n    );\n    function purchaseFor(address buyer, uint256 id, address referrer) external;\n}\n\ncontract MpesaTreasuryAdapter {\n    address public immutable usdt;\n    address public immutable packageManager;\n    address public immutable treasury;\n    address public immutable backendEOA;\n\n    constructor(address _usdt, address _pm, address _treasury, address _backend) {\n        require(_usdt != address(0) && _pm != address(0) && _treasury != address(0) && _backend != address(0), \"bad addr\");\n        usdt = _usdt;\n        packageManager = _pm;\n        treasury = _treasury;\n        backendEOA = _backend;\n    }\n\n    modifier onlyBackend() {\n        require(msg.sender == backendEOA, \"not backend\");\n        _;\n    }\n\n    function purchaseUsingTreasury(address buyer, uint256 packageId, address referrer) external onlyBackend {\n        require(buyer != address(0), \"bad buyer\");\n\n        bytes32 serverRole = IPackageManagerMinimal(packageManager).SERVER_ROLE();\n        require(IPackageManagerMinimal(packageManager).hasRole(serverRole, address(this)), \"no server role\");\n\n        (\n            uint256 entryUSDT,,,,,,bool active,bool exists,\n            \n        ) = IPackageManagerMinimal(packageManager).getPackage(packageId);\n        require(exists && active, \"bad package\");\n\n        require(IERC20Minimal(usdt).transferFrom(treasury, address(this), entryUSDT), \"pull fail\");\n\n        if (IERC20Minimal(usdt).allowance(address(this), packageManager) < entryUSDT) {\n            require(IERC20Minimal(usdt).approve(packageManager, type(uint256).max), \"approve fail\");\n        }\n\n        IPackageManagerMinimal(packageManager).purchaseFor(buyer, packageId, referrer);\n    }\n}\n"
      }
    },
    "settings": {
      "optimizer": { "enabled": true, "runs": 200 },
      "viaIR": true,
      "outputSelection": { "*": { "*": [ "abi", "evm.bytecode", "evm.deployedBytecode", "metadata" ] } }
    }
  }